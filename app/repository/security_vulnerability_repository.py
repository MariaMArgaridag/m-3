import mysql.connector
from utils.id_mapper import IdMapper

class SecurityVulnerabilityRepository:
    def __init__(self, db):
        self.db = db
        self.id_mapper = IdMapper()

    def create(self, vulnerability: str):
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute(
            "INSERT INTO Security_Vulnerabilities (vulnerability) VALUES (%s)",
            (vulnerability,)
        )

        conn.commit()
        internal_id = cursor.lastrowid
        external_id = self.id_mapper.get_external_id(internal_id, 'vulnerability')

        return {
            "id": external_id,
            "vulnerability": vulnerability
        }

    def list(self):
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute("SELECT * FROM Security_Vulnerabilities")
        rows = cursor.fetchall()
        result = []
        for row in rows:
            external_id = self.id_mapper.get_external_id(row['Id'], 'vulnerability')
            result.append({
                "id": external_id,
                "vulnerability": row['Vulnerability']
            })
        return result
    
    def get_by_id(self, external_id: str):
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)
        
        internal_id = self.id_mapper.get_internal_id(external_id)
        if internal_id is None:
            return None

        cursor.execute(
            "SELECT * FROM Security_Vulnerabilities WHERE Id = %s",
            (internal_id,)
        )

        row = cursor.fetchone()
        if row is None:
            return None
        
        return {
            "id": external_id,
            "vulnerability": row['Vulnerability']
        }
    
    def update(self, external_id: str, vulnerability: str):
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)
        
        internal_id = self.id_mapper.get_internal_id(external_id)
        if internal_id is None:
            return None

        cursor.execute(
            "UPDATE Security_Vulnerabilities SET Vulnerability = %s WHERE Id = %s",
            (vulnerability, internal_id)
        )

        if cursor.rowcount == 0:
            return None
        
        conn.commit()

        return {
            "id": external_id,
            "vulnerability": vulnerability
        }
    
    def delete(self, external_id: str):
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)
        
        internal_id = self.id_mapper.get_internal_id(external_id)
        if internal_id is None:
            return False

        try:
            cursor.execute(
                "DELETE FROM Security_Vulnerabilities WHERE Id = %s",
                (internal_id,)
            )

            if cursor.rowcount == 0:
                return False

            conn.commit()
            self.id_mapper.clear_mapping(external_id)
            return True

        except mysql.connector.Error as err:
            conn.rollback()

            if err.errno == 1451:
                return "FK"

            raise err

    def statistics(self):
        """
        Retorna estatísticas sobre vulnerabilidades de segurança:
        - Total de vulnerabilidades
        - Uso de cada vulnerabilidade em ataques
        - Impacto financeiro por vulnerabilidade
        """
        conn = self.db.get_connection()
        cursor = conn.cursor(dictionary=True)

        # Total de vulnerabilidades
        cursor.execute("SELECT COUNT(*) AS total FROM Security_Vulnerabilities")
        total = cursor.fetchone()["total"]

        # Uso de cada vulnerabilidade em ataques
        cursor.execute(
            """
            SELECT
                sv.Id AS vulnerability_id,
                sv.Vulnerability AS vulnerability,
                COUNT(gct.Id) AS usage_count,
                SUM(gct.`Financial Loss (in Million $)`) AS total_financial_loss,
                AVG(gct.`Financial Loss (in Million $)`) AS avg_financial_loss,
                SUM(gct.`Number of Affected Users`) AS total_affected_users,
                AVG(gct.`Number of Affected Users`) AS avg_affected_users
            FROM Security_Vulnerabilities sv
            LEFT JOIN global_cyber_threats gct ON gct.`Security Vulnerability Type` = sv.Id
            GROUP BY sv.Id, sv.Vulnerability
            ORDER BY usage_count DESC
            """
        )
        usage_stats = cursor.fetchall()

        result = {
            "total_vulnerabilities": total,
            "vulnerabilities": []
        }

        for item in usage_stats:
            external_id = self.id_mapper.get_external_id(item["vulnerability_id"], 'vulnerability')
            result["vulnerabilities"].append({
                "vulnerability": {
                    "id": external_id,
                    "vulnerability": item["vulnerability"]
                },
                "usage_count": item["usage_count"] or 0,
                "total_financial_loss": float(item["total_financial_loss"] or 0),
                "avg_financial_loss": float(item["avg_financial_loss"] or 0),
                "total_affected_users": item["total_affected_users"] or 0,
                "avg_affected_users": float(item["avg_affected_users"] or 0)
            })

        return result